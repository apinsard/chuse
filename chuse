#!/usr/bin/python3
#-*-coding:UTF-8-*-
# Distributed under the terms of the GNU General Public License v2

"""chuse is a utility for Portage package manager (namely Gentoo Linux base systems). It enables you
to edit USE flags for a particular ebuild. It is based on emod (https://github.com/Pyntony/emod), a
tool I started to develop for the same purpose but that I never ended.

"emod" was originally developped to avoid forgetting a ">" when running "echo app-dummy/example -qt
gtk >> /etc/portage/package.use" for instance and the overwrite the file. 

I decided to start over because I want this tool to be as much simple as possible. "emod" handles
package.{accept_keywords,env,keywords,license,mask,properties,unmask,use}. Basically this tool will
only be useful for package.use. Other files are rarely modified, and editing them manually would
probably do the job quite good enough.

Usage:
    chuse <atom> [<modifier><flag> ...] [--because <reason>]

    atom:
        [version-selector]<ebuild-cat>/<ebuild-pkg>[-<version>]
        Obviously 'version-selector' and 'version' should never be set without the other.
    version-selector:
        One of : "=", ">", "<", ">=", "<=".
    ebuild-cat:
        An ebuild category (validity won't be checked).
    ebuild-pkg:
        An ebuild package (validity won't be checked).
    version:
        A version of the underlying package (validity won't be checked).
    modifier:
        One of : "-", "+", "%" (% means reset default).
    flag:
        A USE flag (validity won't be checked).
    reason:
        The reason why you changed these USE flags (so that you remember why you set this and if now
        you can reset default for instance).

"""

import re, sys
from datetime import datetime

class AtomError(Exception):
    pass

class PackageUseError(Exception):
    pass

PACKAGE_USE_FILE_PATTERN = '/etc/portage/package.use/%(cat)s/%(pkg)s'

USE_FLAG_MODIFIERS = '+-%'

DATETIME_FORMAT = "[%Y-%m-%dT%H:%M]"

COLORS = True

def _colorize(text, color_code, bold=False):
    start = "\033["
    if bold:
        start += "1;"
    start += str(color_code)+"m"

    end = "\033[0m"

    return start + text + end

def _red(text, bold=False):
    return _colorize(text, 31, bold)

def _orange(text, bold=False):
    return _colorize(text, 33, bold)

def error(message):
    sys.stderr.write(_red("Error: %s\n" % message, bold=True))
    sys.exit(1)

def warning(message):
    sys.stderr.write(_orange("Warning: %s\n" % message))

def parse_atom(atom: "A raw atom as a string") -> "The atom parts as a dict":
    """Parse the given atom and split it to extract:
        
        - the version selector ;
        - the category name ;
        - the package name ;
        - the version ;
        - the slot.
    """
    parts = ['selector', 'cat', 'pkg', 'version', 'slot']
    selector_ptrn = r'(?P<selector>>=|<=|<|=|>)'
    cat_ptrn = r'(?P<cat>[a-z0-9]+(-[a-z0-9]+)?)'
    pkg_ptrn = r'(?P<pkg>[a-z0-9]+(-[a-z0-9]+)*)'
    version_ptrn = r'(?P<version>[0-9]+(\.[0-9]+)*(-r[0-9]+)?)'
    slot_ptrn = r'(?P<slot>.*)'

    pattern = '^'+selector_ptrn+'?'+cat_ptrn+'/'+pkg_ptrn+'(-'+version_ptrn+')?(:'+slot_ptrn+')?$'

    match = re.match(pattern, atom)

    if not match:
        raise AtomError("Invalid atom!")

    result = {'raw': atom}
    for part in parts:
        result[part] = match.group(part)

    return result

def read_current_flags(atom: "An atom as a dict (parsed with `parse_atom`)"
        )-> "The current flags set by the user for this atom as a list of tuples":
    """Look for existing flags formerly set by the user in /etc/portage/package.use

    USE flags are returned as a list of 2-uples in the form ('+'|'-', 'flagname')
    Eg. [('+', 'python'), ('-', 'php')]
    """
    useflags = []

    try:
        """Fetch a line that matches the given atom"""
        with open(PACKAGE_USE_FILE_PATTERN % atom) as f:
            pattern = re.compile('^'+ atom['raw'] +r'\s+([^\s].*)$')
            for line in f.readline():
                match = pattern.match(line)
                if match:
                    raw_flags = re.sub(r'\s+', ' ', match.group(1))
                    for flag in raw_flags.split():
                        if flag[0] == '-':
                            useflags.append(('-', flag[1:]))
                        else:
                            useflags.append(('+', flag))
                    break # Another matching line would be foolish
    except FileNotFoundError:
        pass # Then there is no flag for now
    except NotADirectory:
        raise PackageUseError("Incompatible package.use hierarchy")

    return useflags

def write_changes(atom: "An atom as a dict (parsed with `parse_atom`)"
        , flags: "The USE flags to write (generated with `merge_flags`)"
        , comment: "A comment about the changes made"):
    comment = re.sub('(^)', '# ', comment, flags=re.MULTILINE)

    try:
        with open(PACKAGE_USE_FILE_PATTERN % atom, 'r+') as f:
            pattern = re.compile('^'+ atom['raw'] +r'\s+([^\s].*)$')
            for line in f.readline():
                match = pattern.match(line)
                if match:
                    raw_flags = re.sub(r'\s+', ' ', match.group(1))
                    for flag in raw_flags.split():
                        if flag[0] == '-':
                            useflags.append(('-', flag[1:]))
                        else:
                            useflags.append(('+', flag))

                    break # What would you do then ?
    except FileNotFoundError:
        pass # Then there is no flag for now
    except NotADirectory:
        raise PackageUseError("Incompatible package.use hierarchy")


def merge_flags(cur_flags: "list of current flags", new_flags: "list flags to edit"
        )-> 'Current flags "patched" with new ones as a dict {flag_name: modifier}':
    useflags = {}
    verbose_changes = []

    for flag in cur_flags:
        useflags[flag[1]] = flag[0]

    for flag in new_flags:
        if flag[0] == '%':
            try:
                del useflags[flag[1]]
            except KeyError:
                warning("You did not formerly set the %s use flag. No action needed" % flag[1])
            else:
                verbose_changes[] = "Reset "+ flag[1]
        else:
            useflags[flag[1]] = flag[0]
            if flag[0] == '+':
                verbose_changes[] = "Set "+ flag[1]
            else:
                verbose_changes[] = "Unset "+ flag[1]

    return useflags, ', '.join(verbose_changes)

if __name__ == '__main__':
    try:
        atom = sys.argv[1]
    except IndexError:
        error("Expected at least one argument!")

    reason = None
    flags = []

    iarg = 2
    try:
        while sys.argv[iarg] != '--because':
            flag = sys.argv[iarg]
            modifier = flag[0]
            flag = (modifier, flag[1:])

            if modifier not in USE_FLAG_MODIFIERS:
                error("Invalid use flag modifier, expected one of '%s' before '%s'" % flag)

            flags.append(flag)
            iarg += 1
    except IndexError:
        pass # No reason given
    else:
        reason = ' '.join(sys.argv[iarg+1:]) or "Because I can!"

    try:
        atom = parse_atom(atom)
    except AtomError as e:
        error(e.message)

    try:
        cur_flags = read_current_flags(atom)
    except PackageUseError as e:
        error(e.message)

    new_flags, comment = merge_flags(cur_flags, flags)

    comment = datetime.today().strftime(DATETIME_FORMAT) +' '+ comment + '\n'+ reason

    try:
        write_changes(atom, new_flags, comment)
    except PackageUseError as e:
        error(e.message)

